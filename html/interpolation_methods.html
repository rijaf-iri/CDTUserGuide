<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Spatial Interpolation Methods</title>

<script src="../libs/header-attrs-2.13/header-attrs.js"></script>
<script src="../libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="../libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="../libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="../libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="../libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="../libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="../libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="../libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="../libs/navigation-1.1/tabsets.js"></script>
<link href="../libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="../libs/highlightjs-9.12.0/highlight.js"></script>
<link href="../libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="../libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="../css/styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "../index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">CDT User Guide</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    CDT
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="cdt_file_menu.html">CDT GUI</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="cdt_data_input.html">CDT Data</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Data Preparation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="format_cdt_data.html">Format CDTs Input Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="manipulate_cdt_data.html">Manipulating CDT Station Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="assess_availability.html">Assess Data Availability</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="download_data.html">Download Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="aggregate_ts_data.html">Aggregate Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="regrid_spatial_data.html">Regrid Spatial Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="transform_cdt_dataset.html">Transform NetCDF files into CDT Dataset</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="split_netcdf_files.html">Split NetCDF files into CDT NetCDF format</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="combine_netcdf_files.html">Combine multiple CDT NetCDF format files into one</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="data_extraction.html">Data Extraction</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="data_operation.html">Data Operation</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="blanking_girdded_data.html">Blank Grid Outside Polygons</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="data_conversion.html">Data Format Conversion</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Quality Control
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="check_stations_coords.html">Check Stations Coordinates</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="qc_false_zero.html">False-Zeros Check for daily rainfall</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="qc_outliers_precip.html">Outliers Check for rainfall data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="qc_outliers_temp.html">Outliers Check for temperatures data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="homogeneity_test.html">Homogeneity Test</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Gridding
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="spatial_interpolation.html">Spatial Interpolation</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-submenu">
      <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">Merging Climate Data</a>
      <ul class="dropdown-menu" role="menu">
        <li>
          <a href="downscaling_data.html">Downscaling Data</a>
        </li>
        <li class="divider"></li>
        <li>
          <a href="bias_adjustment.html">Bias Adjustment</a>
        </li>
        <li class="divider"></li>
        <li>
          <a href="merging_data.html">Merging Data</a>
        </li>
        <li class="divider"></li>
      </ul>
    </li>
    <li class="divider"></li>
    <li>
      <a href="scale_merged_data.html">Scale Merged Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="cross_validation.html">Merging - Cross-Validation</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Validation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="validation_cdt_frmt.html">Spatial Points Data (CDT Format)</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="validation_ncdf_frmt.html">Gridded Data (NetCDF Format)</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="validation_multi_data.html">Validate multiple data sets</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="summary_statistics.html">Summary Statistics</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="derived_climate_variables.html">Derived Climate Variables</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="climatologies_anomalies.html">Climatologies and Anomalies</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="spatial_analysis.html">Spatial Analysis</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="daily_rainfall_analysis.html">Daily Rainfall Analysis</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="rainy_season_characteristics.html">Rainy Season Characteristics</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="rainy_season_analysis.html">Rainy Season Analysis</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="climate_extremes_indices.html">Climate Extremes Indices</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="drought_indices.html">Drought Indices</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Visualization
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="plot_station_data.html">Plot CDT Station Data</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="plot_cdt_dataset.html">Plot CDT Gridded Dataset</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="plot_ncdf_one.html">Plot NetCDF Data (One File)</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="plot_ncdf_seq.html">Plot NetCDF Data (Sequential Files)</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="plot_ncdf_vars.html">Plot NetCDF Data (Multiple Variables)</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="plot_multiple_dataset.html">Plot multiple data sets</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/rijaf-iri/CDT">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Spatial Interpolation Methods</h1>

</div>


<div id="global-vs.-local-interpolation" class="section level2">
<h2>Global vs. local interpolation <a name="interp.local"></a></h2>
<p>A global interpolation uses all available known points in the study area to estimate the unknown value of a point located within the study area. Local interpolation on the other hand, uses a sample of known points to estimate the unknown value.</p>
<p>Local interpolation is designed to capture the local or short-range variation, while global interpolation assess global spatial structures and the local or short-range variation.</p>
<p>Global interpolation generally produces smoother surfaces. For many meteorological variables, it is more accurate to estimate the unknown value at a point using a local method than a global method.</p>
<p>The difference between local and global interpolation lies in the number of points used in the estimation of the unknown value.</p>
<p>To perform a spatial interpolation with CDT, you have to provide the minimum (<strong><em>nmin</em></strong>) and maximum (<strong><em>nmax</em></strong>) number of neighbors points to be used to estimate the unknown value at a grid node, and the maximum distance (<strong><em>maxdist</em></strong>) within which the neighbor points will be selected. A radius is generated around each grid node from which neighbor points are selected to be used in the interpolation. The unit of <em>maxdist</em> is in decimal degree.</p>
<p>If there are more neighbor points than <em>nmax</em> found inside the search radius then the <em>nmax</em> points nearest to the grid node are only used to interpolate. If there are less neighbor points than <em>nmin</em> found inside the search radius then the value of the grid node is set to missing.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/interp_maxdist.png" style="width:70.0%;height:33.0%" />
</center>
<p><br></p>
<p>The figure below shows a maps of global and local interpolation using the inverse distance weighted method. The global interpolation uses all station observations; the local interpolation is interpolated using <em>nmin</em> = 2, <em>nmax</em> = 5 and <em>maxdist</em> = 0.3 degree.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/global_local_interp.png" style="width:100.0%;height:100.0%" />
</center>
<p><br></p>
</div>
<div id="deterministic-vs.-stochastic-interpolation" class="section level2">
<h2>Deterministic vs. stochastic interpolation <a name="interp.stochas"></a></h2>
<p>There are two main groupings of interpolation methods: deterministic and stochastic. Deterministic interpolation method is based on exactly predetermined spatial contexts such as the extent of similarity or the degree of smoothing. Stochastic interpolation method, on the other hand, considers random functions, including the spatial dependence between points; it quantifies the spatial autocorrelation among measured points and account for the spatial configuration of the sample points around the prediction location.</p>
<p>Deterministic interpolation method provides no assessment of errors with predicted values, while a stochastic interpolation method offers assessment of predictions errors with estimated variances.</p>
<p>CDT has 4 deterministic interpolation methods: inverse distance weighted, modified Shepard interpolation, Spheremap interpolation method and nearest neighbor; and 2 stochastic interpolation methods: ordinary kriging and universal kriging.</p>
</div>
<div id="cdt-spatial-interpolation-methods" class="section level2">
<h2>CDT spatial interpolation methods</h2>
<div id="nearest-neighbor-nn" class="section level3">
<h3>Nearest Neighbor (NN) <a name="interp.nn"></a></h3>
<p>The nearest neighbor method assigns the value from the nearest observation to a certain grid node.</p>
<p>The application of NN is limited in meteorology, especially when dealing with continuous variables. But it can give a better result when using a dense station networks. The NN method may be used with categorical variables.</p>
<p>To limit the influence of one point a maximum distance of influence can be applied. The elevation data can be included in the interpolation process as a third dimension to take account the influence of the elevation.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/nn_interp.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> Nearest neighbor interpolation methods using maxdist=0.5 </span>
</center>
<p><br></p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/nn_elevation.png" style="width:50.0%;height:47.0%" /><br />
<span class="img-caption"> Elevation data used to interpolate </span>
</center>
<p><br></p>
</div>
<div id="inverse-distance-weighting-idw" class="section level3">
<h3>Inverse Distance Weighting (IDW) <a name="interp.idw"></a></h3>
<p>IDW is an advanced nearest neighbor approach that allows including more observations than only the nearest observation. The value at a certain grid node is obtained from a linear combination of the neighboring stations. The weight of each observation is determined by the distance, the distance function is non-linear.</p>
<p>Mathematically, it can be described by considering <span class="math inline">\(z(x)\)</span> as the interpolated value at a point <span class="math inline">\(x\)</span>, <span class="math inline">\(z(x_i)\)</span> is the observed value at the point <span class="math inline">\(x_i\)</span>, <span class="math inline">\(n\)</span> is the number of points observations used to interpolate, and <span class="math inline">\(w_i\)</span> denotes the weighting factor:</p>
<p><span class="math display">\[
z(x) = \sum_{i=1}^n w_i z(x_i)
\]</span></p>
<p>The weight <span class="math inline">\(w_i\)</span> is a mathematical function whose values depends on the distance between <span class="math inline">\(x\)</span> and <span class="math inline">\(x_i\)</span>. Generally Euclidean distance is used for IDW. There are several variants of the weighting factors, but the two most used are inverse power and exponential:</p>
<p><span class="math display">\[
w_i = \frac{w(d_i)}{\sum_{i=1}^n w(d_i)}
\]</span></p>
<p>where <span class="math inline">\(d_i\)</span> is the distance between <span class="math inline">\(x\)</span> and <span class="math inline">\(x_i\)</span>.</p>
<p>For the inverse power function</p>
<p><span class="math display">\[ w(d) = \frac{1}{{d}^\beta} \]</span></p>
<p>and for the exponential function</p>
<p><span class="math display">\[ w(d) = e^{-\left(\frac{d}{d_0}\right)^\beta} \]</span></p>
<p>where <span class="math inline">\(\beta\)</span> denotes the weighting power and <span class="math inline">\(d_0\)</span> is the decorrelation distance.</p>
<p>The most widely used weighting power is <span class="math inline">\(\beta = 2\)</span>. The figures below show a comparison between the inverse power and exponential weighting functions. The inverse power decreases faster than the exponential function, this implies that the exponential produces a smoother interpolated surface than inverse power function.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/w_invpow_expo.png" style="width:70.0%;height:70.0%" /><br />
<span class="img-caption"> Comparison between inverse power and exponential weighting functions with β=2 </span>
</center>
<p><br></p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/idw_w_interp.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> IDW interpolation using inverse power and exponential weighting functions; β=2, nmin=3, nmax=6, maxdist=0.5 </span>
</center>
<p><br></p>
<p>The choice of this weighting power <span class="math inline">\(\beta\)</span> can significantly affect the estimation quality. The optimal weighting power depends on the spatial structure of the data. Higher weighting power values emphasize the influence of the points nearest to the grid node, resulting in a more detailed and less smooth interpolated surface. A smaller power value gives more influence to distant points, and results in a more averaged and smoothed interpolated surface.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/w_pow_beta.png" style="width:70.0%;height:70.0%" /><br />
<span class="img-caption"> Weighting power curves with different values of β </span>
</center>
<p><br></p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/idw_interp_pow_beta.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> IDW interpolation using inverse power weighting function with two different values of β: 0.5 and 4 </span>
</center>
<p><br></p>
<p>In the same way, the choice of the decorrelation distance <span class="math inline">\(d_0\)</span> can affect the smoothness of the interpolated surface. A higher value of <span class="math inline">\(d_0\)</span> results in a more smoothed interpolated surface.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/w_expo_d0.png" style="width:70.0%;height:70.0%" /><br />
<span class="img-caption"> Decorrelation distance curves with different values of <em>d</em><sub>0</sub> </span>
</center>
<p><br></p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/idw_interp_expo_d0.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> IDW interpolation using exponential weighting function with two different values of <em>d</em><sub>0</sub>: 60 and 500 km </span>
</center>
<p><br></p>
</div>
<div id="modified-shepard" class="section level3">
<h3>Modified Shepard <a name="interp.shpd"></a></h3>
<p>The modified Shepard interpolation method is modification of the IDW method, with the aim of reducing the expressive local values (outliers, extremes) that could cause <em>bull-eyeing</em> or <em>butterfly shapes</em> effects. The weighting function is designed to have local support. The estimation using modified Shepard interpolation method is done by:</p>
<p><span class="math display">\[
z(x) = \sum_{i=1}^n w_i z(x_i)
\]</span></p>
<p>where <span class="math inline">\(z(x)\)</span> represents the interpolated value at a point <span class="math inline">\(x\)</span>, <span class="math inline">\(z(x_i)\)</span> is the observed value at the point <span class="math inline">\(x_i\)</span>, <span class="math inline">\(n\)</span> is the number of points observations used to interpolate, and <span class="math inline">\(w_i\)</span> denotes the weighting factor. There are several variants of the weighting factor, the following equation is used in CDT:</p>
<p><span class="math display">\[
w_i = \frac{w(d_i)}{\sum_{i=1}^n w(d_i)}
\]</span></p>
<p>where <span class="math inline">\(d_i\)</span> is the distance between <span class="math inline">\(x\)</span> and <span class="math inline">\(x_i\)</span>, and the weighting function <span class="math inline">\(w(d)\)</span> is given by</p>
<p><span class="math display">\[
w(d) = \left[\frac{R - d}{R d}\right]^\beta
\]</span></p>
<p>where <span class="math inline">\(R\)</span> is the distance from the interpolation location to the most distant point and <span class="math inline">\(\beta\)</span> denotes the weighting power.</p>
<p>The choice of this weighting power <span class="math inline">\(\beta\)</span> can affect the smoothness of the interpolated surface. A higher value of <span class="math inline">\(\beta\)</span> results in a more smoothed interpolated surface.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/w_shpd_beta.png" style="width:70.0%;height:70.0%" /><br />
<span class="img-caption"> Weighting power curves with different values of β </span>
</center>
<p><br></p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/shpd_interp_pow_beta.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> Modified Shepard interpolation using two different values of β: 1 and 4 </span>
</center>
<p><br></p>
</div>
<div id="kriging" class="section level3">
<h3>Kriging <a name="interp.kriging"></a></h3>
<p>Kriging is a geostatistical interpolation method that considers both the distance and the degree of variation between known data points when estimating values in unknown areas. Geostatistic is a branch of statistics that explores natural phenomena that are both random and structural.</p>
<p>Kriging recognizes that the simple smooth mathematical function can not be used in modelling the spatial variation of any continuous attribute value. The variation can be better described by a stochastic surface with an attribute known as a regionalized variable. The regionalized variable theory assumes that the value of a random variable <span class="math inline">\(Z\)</span> at a location <span class="math inline">\(x\)</span> is given by:</p>
<p><span class="math display">\[ 
Z(x) = m(x) + \varepsilon^{&#39;}(x) + \varepsilon^{&#39;&#39;}
\]</span></p>
<p>where <span class="math inline">\(m(x)\)</span> is a deterministic function describing a structural component of <span class="math inline">\(Z\)</span> at <span class="math inline">\(x\)</span>, <span class="math inline">\(\varepsilon^{&#39;}(x)\)</span> represents the random spatially correlated component (it is the regionalized variable), and <span class="math inline">\(\varepsilon^{&#39;&#39;}\)</span> is a random noise component following normal distribution (non-spatially correlated term, also known as nugget variance)).</p>
<p>When structural effects have been accounted for and the variation is homogeneous in its<br />
variation, the semivariance <span class="math inline">\(\gamma (h)\)</span> can be estimated by:</p>
<p><span class="math display">\[
\hat{\gamma}(h) = \frac{1}{2n} \sum_{i=1}^n \{z(x_i) - z(x_i + h)\}^2
\]</span></p>
<p>where <span class="math inline">\(n\)</span> is number of pairs of sample points of observations of the values of attribute <span class="math inline">\(z\)</span> separated by distance <span class="math inline">\(h\)</span>.</p>
<p>A plot of <span class="math inline">\(\gamma (h)\)</span> against <span class="math inline">\(h\)</span> is called a semivariogram and gives a quantitative description of the regionalized variation. An important factor of the variogram is the range, which describes the distance when the data points become spatially independent.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/variogram.png" style="width:80.0%;height:44.0%" /><br />
<span class="img-caption"> Variogram example </span>
</center>
<p><br></p>
<p>The variogram can be used to estimate the optimal weights needed for interpolation. The value of <span class="math inline">\(z(x)\)</span> for an unknown point <span class="math inline">\(x\)</span> is expressed as follows:</p>
<p><span class="math display">\[
z(x) = \sum_{i=1}^n \lambda_i z(x_i)
\]</span></p>
<p>where <span class="math inline">\(z(x_i)\)</span> is the measured value at the location <span class="math inline">\(x_i\)</span>, <span class="math inline">\(n\)</span> is the number of points observations used to interpolate, and <span class="math inline">\(\lambda_i\)</span> denotes the weighting factor which is computed from the variogram model.</p>
<p>CDT uses the package <a href="https://cran.r-project.org/web/packages/gstat/index.html">gstat</a> to fit the variogram. Read the <a href="http://www.gstat.org/gstat.pdf">gstat user’s manual</a> for more information about the kriging.</p>
<div id="ordinary-kriging" class="section level4">
<h4>Ordinary Kriging</h4>
<p>Ordinary kriging is the basic form of Kriging. The prediction by ordinary kriging is a linear combination of the measured values. The spatial correlation between the data, as described by the variogram, determines the weights.</p>
<p>Ordinary kriging assumes the model</p>
<p><span class="math display">\[ 
Z(x) = \mu + \varepsilon^{&#39;}(x) + \varepsilon^{&#39;&#39;}
\]</span></p>
<p>where <span class="math inline">\(\mu\)</span> is an unknown constant. One of the main issues concerning ordinary kriging is the assumption of intrinsic stationarity (a constant mean), unfortunately meteorological variables are often not stationary. In some case this issue can be eliminated by performing a local interpolation and using different sizes and shapes of the search radius.</p>
<p>Ordinary kriging can use either semivariograms or covariances, use transformations and remove trends, and allow for measurement error.</p>
</div>
<div id="universal-kriging" class="section level4">
<h4>Universal Kriging</h4>
<p>Universal kriging is also known as <em>kriging with a trend/external drift</em>. It uses a regression model as part of the kriging process to model the mean value expressed as a linear or quadratic trend.</p>
<p>Universal kriging assumes the model</p>
<p><span class="math display">\[ 
Z(x) = \mu(x) + \varepsilon^{&#39;}(x) + \varepsilon^{&#39;&#39;}
\]</span></p>
<p>where <span class="math inline">\(\mu(x)\)</span> is some deterministic function (regression model).</p>
<p>Universal kriging considers the influence of auxiliary factors on the predicted variable and make use of the spatial autocorrelation of the predicted variable and its cross-correlation information with related auxiliary variables, but they have different modeling methods and calculation processes. Universal kriging describes the trend change of the predicted variable in a certain spatial neighborhood by establishing<br />
the functional relationship between the predicted variable and explanatory variables.</p>
<p>Universal kriging can use either semivariograms or covariances, use transformations, and allow for measurement error.</p>
<p>The figure below shows a comparison of the ordinary and universal kriging interpolation methods. The ordinary kriging uses a Gaussian variogram model with partial sill = 2.095, range = 0.641 degree and nugget = 0.0864. The universal kriging includes the elevation data as auxiliary variable, and a Gaussian variogram model with partial sill = 1.648 and range = 0.4167 degree.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/kriging_interp.png" style="width:100.0%;height:100.0%" /><br />
<span class="img-caption"> Ordinary and universal kriging </span>
</center>
<p><br></p>
</div>
</div>
<div id="spheremap" class="section level3">
<h3>Spheremap <a name="interp.sphrmap"></a></h3>
<p>The Spheremap interpolation method is an application of Shepard’s scheme on a sphere. It takes into account the spherically-derived distances and angles between the grid nodes and stations. This interpolation technique is implemented at the Global Precipitation Climatology Centre (GPCC). Willmott et al. (1985) identified weights <span class="math inline">\(S_k\)</span> for the interpolation procedures according to three categories of distance as follows:</p>
<p><span class="math display">\[
S_k = \begin{cases}
d_{j,k}^{-1},  &amp; d_{j,k} \le r_j/3 \\
\frac{27}{4r_j} \left(\frac{d_{j,k}}{r_j}-1\right), &amp; r_j/3 \le d_{j,k} \le r_j \\
0, &amp; d_{j,k} \gt r_j
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(r_j\)</span> is the search radius and <span class="math inline">\(d_j\)</span>, <span class="math inline">\(d_{j,k}\)</span> is the distance from grid node <span class="math inline">\(j\)</span> to nearby station <span class="math inline">\(k\)</span>.</p>
<p>The estimation of the value at a grid node <span class="math inline">\(j\)</span> using Spheremap interpolation method is given by:</p>
<p><span class="math display">\[
\hat{z_j} = \begin{cases}
\sum_{k=1}^{n_j} f_k (z_k + \Delta z_k), &amp; d_{j,l} \gt \epsilon \\
\\
\frac{1}{m} \sum_{k=1}^{n_j} z_k, &amp; d_{j,l} \le \epsilon
\end{cases}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
f_k = \frac{W_k}{\sum_{k=1}^{n_j} W_k}
\]</span></p>
<p>where <span class="math inline">\(\hat{z_j}\)</span> is the interpolated value at the grid node <span class="math inline">\(j\)</span> and <span class="math inline">\(z_k\)</span> is the observed value at the station <span class="math inline">\(k\)</span>, <span class="math inline">\(\Delta z_k\)</span> is an incremental correction added to <span class="math inline">\(z_k\)</span>, <span class="math inline">\(d_{j,l}\)</span> is the distance from grid node <span class="math inline">\(j\)</span> to nearby station <span class="math inline">\(l\)</span>, <span class="math inline">\(m\)</span> is the number of stations within the radius <span class="math inline">\(\epsilon\)</span> of grid node <span class="math inline">\(j\)</span>. <span class="math inline">\(n_j\)</span> (<span class="math inline">\(nmin \le n_j \le nmax\)</span>) is set of nearby stations, it is used to estimate the search radius. The weights <span class="math inline">\(W_k\)</span> are computed from</p>
<p><span class="math display">\[
W_k = S_{k}^2 \left(1 + \frac{T_k}{\sum_{l=1}^{n_j} S_l} \right), ~~~~~ l \neq k 
\]</span></p>
<p><span class="math inline">\(T_k\)</span> is the directional isolation of each nearby station with regard to <span class="math inline">\(j\)</span></p>
<p><span class="math display">\[
T_k = \sum_{l=1}^{n_j} S_l [1 - \cos \theta_j(k,l)], ~~~~~ l \neq k 
\]</span></p>
<p>where <span class="math inline">\(\theta_j(k,l)\)</span> is the angular separation of the nearby stations <span class="math inline">\(k\)</span> and <span class="math inline">\(l\)</span> when the vertex of the angle is defined as te grid node <span class="math inline">\(j\)</span>.</p>
<p>See Willmott et al. for more details.</p>
<p>The figure below shows a comparison of the Spheremap, modified Shepard and IWD interpolation. The interpolated surface from the Spheremap method is less smoothed than the modified Shepard and IDW.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/spheremap_interp.png" style="width:80.0%;height:80.0%" /><br />
<span class="img-caption"> Comparison between Spheremap, modified Shepard and IDW interpolation methods </span>
</center>
<p><br></p>
<p><strong><em>References</em></strong>:</p>
<p>Willmott, C. J., Rowe, C. M., and Philpot, W. D. (1985): Small-scale climate maps: A sensitivity analysis of some common assumptions associated with grid-point interpolation and contouring. American Cartographer, 12, 5-16.</p>
</div>
<div id="bilinear" class="section level3">
<h3>Bilinear <a name="interp.bilinear"></a></h3>
<p>A bilinear interpolation method is simply linear interpolations, first along the x-axis and then along the y-axis. The weighting for the interpolation is given by the area ratio of the four rectangles splitted by the grid node to their area sum.</p>
<p>Suppose that we want to interpolate the value <span class="math inline">\(z\)</span> at a grid node <span class="math inline">\((x, y)\)</span>, which is surrounded by four rectangular points <span class="math inline">\((x_1, y_1)\)</span>, <span class="math inline">\((x_1, y_2)\)</span>, <span class="math inline">\((x_2, y_1)\)</span> and <span class="math inline">\((x_2, y_2)\)</span> with observed values <span class="math inline">\(z_{11}\)</span>, <span class="math inline">\(z_{12}\)</span>, <span class="math inline">\(z_{21}\)</span> and <span class="math inline">\(z_{22}\)</span>, respectively. The figure below shows the configuration of a grid node on which conventional bilinear interpolation proceeds using the four rectangular points surrounding the grid node.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/interp_bilinear.png" style="width:50.0%;height:50.0%" />
</center>
<p><br></p>
<p>The interpolation is given by</p>
<p><span class="math display">\[
z = w_{11} z_{11} + w_{12} z_{12} + w_{21} z_{21} + w_{22} z_{22}
\]</span></p>
<p>where</p>
<p><span class="math display">\[
w_{11} = \frac{(x_2 − x) (y_2 − y)}{(x_2 − x_1) (y_2 − y_1)}\\
w_{12} = \frac{(x_2 − x) (y − y_1)}{(x_2 − x_1) (y_2 − y_1)}\\
w_{21} = \frac{(x − x_1) (y_2 − y)}{(x_2 − x_1) (y_2 − y_1)}\\
w_{22} = \frac{(x − x_1) (y − y_1)}{(x_2 − x_1) (y_2 − y_1)}
\]</span></p>
<p>CDT mainly uses bilinear interpolation for regridding a gridded data from low resolution to a high resolution data.</p>
</div>
</div>
<div id="spatial-smoothing" class="section level2">
<h2>Spatial smoothing <a name="Spatial.smoothing"></a></h2>
<p>To perform a spatial smoothing CDT computes the average of the predicted values over a defined grid nodes located inside a block (square or rectangle) centered at the grid nodes. To define the block, there are two choices: using a Gaussian quadrature with 16 grid nodes or providing the width and the number of grid nodes for the latitude and longitude.</p>
<div id="block-created-with-a-gaussian-quadrature" class="section level3">
<h3>Block created with a Gaussian quadrature</h3>
<p>The Gaussian quadrature method is an approximate method of calculation of a definite integral of a function. The approximation is the weighted sum of function values at specified points within the domain of integration.</p>
<p>A quadrature method is of the form</p>
<p><span class="math display">\[
\int_{a}^{b} f(x)dx \approx \sum_{j=0}^{n} w_j f(x_j)
\]</span></p>
<p>where <span class="math inline">\(x_j\)</span> are equally spaced nodes and <span class="math inline">\(w_j\)</span> are the weights.</p>
<p>The most common domain of integration used in Gaussian quadrature is the interval [−1, 1] and the nodes will all be contained in this interval.<br />
In Gauss Legendre quadrature <span class="math inline">\(x_j\)</span> are the roots of a Legendre polynomial <span class="math inline">\(P_n (x)\)</span> of degree <span class="math inline">\(n\)</span>. The Legendre polynomial has exactly <span class="math inline">\(n\)</span> real and various roots in the interval [−1, 1]. The weights <span class="math inline">\(w_j\)</span> of the Gaussian quadrature formula are defined by</p>
<p><span class="math display">\[
w_j= \frac{1 - x_{j}^2}{[nP_{n-1} (x_j)]^2} = \frac{1}{[P_{n}^{&#39;} (x_j)]^2}
\]</span></p>
<p>For <span class="math inline">\(n = 4\)</span>, the nodes and weights are as follows</p>
<div class="collapseSimpleTable">
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(j\)</span></th>
<th align="right"><span class="math inline">\(x_j\)</span></th>
<th align="right"><span class="math inline">\(w_j\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td align="right">-0.4305681558</td>
<td align="right">0.1739274226</td>
</tr>
<tr class="even">
<td>2</td>
<td align="right">-0.1699905218</td>
<td align="right">0.3260725774</td>
</tr>
<tr class="odd">
<td>3</td>
<td align="right">0.1699905218</td>
<td align="right">0.3260725774</td>
</tr>
<tr class="even">
<td>4</td>
<td align="right">0.4305681558</td>
<td align="right">0.1739274226</td>
</tr>
</tbody>
</table>
</div>
<p>For spatial interpolation the prediction of a point can be done over a rectangular block centred at prediction location (block-to-block: one block for each dimension). The prediction of one point is computed by averaging the predicted points formed by the rectangular block obtained from Gauss quadrature with 4 nodes in each dimension.</p>
<p>The approximation of a function <span class="math inline">\(f\)</span> (semivariances, covariances, coordinate polynomials or inverse distance weighted interpolations) over a block-to-block <span class="math inline">\(B_x\)</span> and <span class="math inline">\(B_y\)</span> can be obtained with</p>
<p><span class="math display">\[
f(B_x,B_y ) \approx \sum_{i=1}^{n}\sum_{j=1}^{m} w_i w_j f(dx_i, dy_j)
\]</span></p>
<p>where <span class="math inline">\(dx_i\)</span> is the discretization of <span class="math inline">\(B_x\)</span> and <span class="math inline">\(dy_j\)</span> for <span class="math inline">\(B_y\)</span>.</p>
<p>The nodes can be multiplied by a factor to extend the size of the domain. Let’s denote by <span class="math inline">\(block_x\)</span> the factor to be multiplied to <span class="math inline">\(B_x\)</span>, which is the width of the block in the longitude direction, and <span class="math inline">\(block_y\)</span> for <span class="math inline">\(B_y\)</span> in the latitude direction. The figures below show the size of the different values of <span class="math inline">\(block_x\)</span> and <span class="math inline">\(block_y\)</span>. The units of <span class="math inline">\(block_x\)</span> and <span class="math inline">\(block_y\)</span> are the same as the units of coordinates of the stations data to interpolate.</p>
<table>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(block_x = 0\)</span> and <span class="math inline">\(block_y = 0\)</span></th>
<th align="center"><span class="math inline">\(block_x = 1\)</span> and <span class="math inline">\(block_y = 1\)</span></th>
<th align="center"><span class="math inline">\(block_x = 2\)</span> and <span class="math inline">\(block_y = 2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="../images/gridding/spatial_interpolation/gauss_grid_block0.jpg" /></td>
<td align="center"><img src="../images/gridding/spatial_interpolation/gauss_grid_block1.jpg" /></td>
<td align="center"><img src="../images/gridding/spatial_interpolation/gauss_grid_block2.jpg" /></td>
</tr>
</tbody>
</table>
<div style="line-height: 100%;">
<p>(<strong><span style="color: black; font-size:2rem;">+</span></strong>) the grid nodes for the interpolation; (<strong><span style="color: red; font-size:3rem;vertical-align: middle">•</span></strong>) one grid node to interpolate, taken as example to show the size of the block; (<strong><span style="color: red; font-size:2rem;">+</span></strong>) points on which the data will be interpolated before averaging it to get the value at (<strong><span style="color: red; font-size:3rem;vertical-align: middle">•</span></strong>).</p>
</div>
<p>To set the size of the block in CDT, you can use the function <code>interpolation.options()</code> for the spatial interpolation menu, <code>biascoeff.options()</code> for the bias adjustment menus, and <code>merging.options()</code> for the merging menus. For example, to use a Gaussian quadrature defined block with 1.5 degree width in longitude and 2 degree width in latitude</p>
<pre class="r"><code>merging.options(blockType = &quot;gaussian&quot;, blockSize = c(1.5, 2))</code></pre>
<p>The figure below shows the maps of interpolated stations data using different blocks values: 0 (no smoothing), 0.5, 1, 1.5 and 2 degree. The more you increase the value of the block, the more the interpolated surface is smooth. Using a block mean tends to remove the bullseye effect from the interpolated surface.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/interp_block_gauss.png" style="width:100.0%;height:100.0%" />
</center>
<p><br></p>
</div>
<div id="user-defined-rectangular-shaped-block" class="section level3">
<h3>User defined rectangular shaped block</h3>
<p>You can define the size of the block by specifying the width and the increment to use for the longitude and latitude.</p>
<p>In CDT the creation of the block can be done with the function <code>interpolation.options()</code> for the spatial interpolation menu,<code>biascoeff.options()</code> for the bias adjustment menus and <code>merging.options()</code> for the merging menus. For example, to create a block with 2 degree width and increment 0.15 degree in longitude and 1 degree width and increment 0.1 degree in latitude</p>
<pre class="r"><code>## blockSize is a vector of length 4 in the form (width_x, by_x, width_y, by_y)
merging.options(blockType = &quot;userdefined&quot;, blockSize = c(2, 0.15, 1.5, 0.1))</code></pre>
<p>We can represent it in a grid as follow</p>
<table>
<thead>
<tr class="header">
<th align="center">no smoothing</th>
<th align="center"><span class="math inline">\(width_x = 2\)</span>; <span class="math inline">\(by_x = 0.15\)</span>; <span class="math inline">\(width_y = 1.5\)</span>; <span class="math inline">\(by_y = 0.1\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="../images/gridding/spatial_interpolation/gauss_grid_block0.jpg" /></td>
<td align="center"><img src="../images/gridding/spatial_interpolation/rect_grid_block.jpg" /></td>
</tr>
</tbody>
</table>
<div style="line-height: 100%;">
<p>(<strong><span style="color: black; font-size:2rem;">+</span></strong>) the grid nodes for the interpolation; (<strong><span style="color: red; font-size:3rem; vertical-align: middle">•</span></strong>) one grid node to interpolate, taken as example to show the size of the block; (<strong><span style="color: red; font-size:2rem;">+</span></strong>) points on which the data will be interpolated before averaging it to get the value at (<strong><span style="color: red; font-size:3rem; vertical-align: middle">•</span></strong>).</p>
</div>
<p>The figure below shows the maps of interpolated stations data using different blocks values: no smoothing, <code>blockSize = c(0.5, 0.1, 0.5, 0.1)</code>, <code>blockSize = c(1, 0.15, 1, 0.15)</code>, <code>blockSize = c(1.5, 0.2, 1.5, 0.2)</code> and <code>blockSize = c(2, 0.25, 2, 0.25)</code>. The larger is the size of the block, the smoother is the interpolated surface.</p>
<br>
<center>
<img src="../images/gridding/spatial_interpolation/interp_block_rect.png" style="width:100.0%;height:100.0%" />
</center>
<p><br></p>
</div>
</div>

<footer class="navbar navbar-inverse  navbar-fixed-bottom">
    <p>
        <small class="footer">
            <a href="../index.html">Climate Data Tools, 2019</a> &nbsp;
            <a class="navbar-footer" href="https://iri.columbia.edu/"><img src="../images/common/iri_logo_full.gif" alt="IRI" /></a>
        </small>
    </p>
</footer>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "../libs/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
